.
├── Makefile
├── include
│   ├── AbstractGrid.hh
│   ├── DynamicBitMap.hh
│   ├── DynamicObstacle.hh
│   ├── DynamicObstacleGenerator.hh
│   ├── NavMesh.hh
│   ├── NavMeshGenerator.hh
│   └── StaticBitMap.hh
├── main.cc
├── src
│   ├── AbstractGrid.cc
│   ├── DynamicBitMap.cc
│   ├── DynamicObstacle.cc
│   ├── DynamicObstacleGenerator.cc
│   ├── NavMesh.cc
│   ├── NavMeshGenerator.cc
│   └── StaticBitMap.cc
└── utils
    └── map_baker.py

3 directories, 17 files


================ FILE CONTENTS ================

==> ./include/AbstractGrid.hh <==
#ifndef BACKEND_LAYER1_ABSTRACTGRID_HH
#define BACKEND_LAYER1_ABSTRACTGRID_HH

#include <utility> 
#include "Coordinates.hh"
#include "Resolution.hh" 

namespace Backend {
namespace Layer1 {

    class AbstractGrid {
    protected:
        int width;
        int height;
        Backend::Common::Resolution resolution;

    public:
        AbstractGrid(int w, int h, Backend::Common::Resolution res);

        // Virtual Destructor is REQUIRED for inheritance safety
        virtual ~AbstractGrid() = default;

        std::pair<int, int> GetDimensions() const;
        
        // Get the resolution of this grid (for physical scale calculations)
        Backend::Common::Resolution GetResolution() const;
        
        bool IsWithinBounds(Backend::Common::Coordinates coords) const;

        // The Pure Virtual Contract
        virtual bool IsAccessible(Backend::Common::Coordinates coords) const = 0;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/DynamicBitMap.hh <==
#ifndef BACKEND_LAYER1_DYNAMICBITMAP_HH
#define BACKEND_LAYER1_DYNAMICBITMAP_HH

#include <vector>
#include <mutex>
#include "AbstractGrid.hh"
#include "StaticBitMap.hh"
#include "DynamicObstacle.hh"

namespace Backend {
namespace Layer1 {

    class DynamicBitMap : public AbstractGrid {
    private:
        std::vector<bool> activeGrid;
        
        // Critical for Layer 3 (Reading) vs Layer 1 (Writing) safety
        mutable std::mutex mapMutex; 

    public:
        // Constructor copies the static map initially
        explicit DynamicBitMap(const StaticBitMap& source);

        bool IsAccessible(Backend::Common::Coordinates coords) const override;

        // The Update Loop
        // We use the Static Map to "Reset" the canvas, then paint obstacles
        void Update(const std::vector<DynamicObstacle>& obstacles, const StaticBitMap& source);
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/DynamicObstacle.hh <==
#ifndef BACKEND_LAYER1_DYNAMICOBSTACLE_HH
#define BACKEND_LAYER1_DYNAMICOBSTACLE_HH

#include <vector>
#include "Coordinates.hh"

namespace Backend {
namespace Layer1 {

    class DynamicObstacle {
    private:
        int size; 
        Backend::Common::Coordinates top_left_anchor;

    public:
        DynamicObstacle(Backend::Common::Coordinates anchor, int s);

        std::vector<Backend::Common::Coordinates> GetOccupiedCells() const;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/DynamicObstacleGenerator.hh <==
#ifndef BACKEND_LAYER1_DYNAMICOBSTACLEMANAGER_HH
#define BACKEND_LAYER1_DYNAMICOBSTACLEMANAGER_HH

#include <vector>
#include "DynamicObstacle.hh"

namespace Backend {
namespace Layer1 {

    class DynamicObstacleManager {
    private:
        std::vector<DynamicObstacle> active_obstacles;

    public:
        // Spawns a new obstacle within the given map bounds
        void SpawnRandomObstacle(int mapWidth, int mapHeight);
        
        // Spawns an obstacle at a specific location with given size
        void SpawnObstacleAt(Backend::Common::Coordinates coords, int size);

        const std::vector<DynamicObstacle>& GetActiveObstacles() const;
        
        void Clear();
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/NavMesh.hh <==
#ifndef BACKEND_LAYER1_NAVMESH_HH
#define BACKEND_LAYER1_NAVMESH_HH

#include <vector>
#include <string>
#include "Coordinates.hh" // From common

// Since Node and Edge are simple structs defined in Common, we use them here.
// Ideally, create Node.hh and Edge.hh in Common, or define them here if specific to NavMesh.
// Based on your UML, they seem to be in Common/Shared Types.
// Assuming they are defined in a file like "GraphTypes.hh" or similar in common.
// For this implementation, I will define local structs if they aren't in common yet, 
// but based on your architecture, they should be imported.

namespace Backend {
namespace Common {
    // Re-declaring for context (remove if included via header)
    struct Node {
        Coordinates coords;
    };
    
    struct Edge {
        int targetNodeId;
        float cost;
    };
}

namespace Layer1 {

    class NavMesh {
    private:
        // The Nodes (Polygons/Centroids)
        std::vector<Backend::Common::Node> allNodes;

        // Adjacency List: Index = Source Node ID, Value = List of Edges
        std::vector<std::vector<Backend::Common::Edge>> adjacencyList;

    public:
        // Constructor
        NavMesh();

        // --- Graph Accessors ---
        const std::vector<Backend::Common::Node>& GetAllNodes() const;
        const std::vector<Backend::Common::Edge>& GetNeighbors(int nodeId) const;

        // --- Geometry Lookups ---
        
        // Converts a world coordinate (x,y) to the nearest NavMesh Node ID.
        // Returns -1 if not accessible or out of bounds.
        int GetNodeIdAt(Backend::Common::Coordinates coords) const;

        // --- Modifiers (Used by Generator) ---
        void AddNode(Backend::Common::Coordinates centroid);
        void AddEdge(int sourceId, int targetId, float cost);
        
        // Remove nodes that have no edges (unreachable)
        // Returns the number of nodes removed
        int RemoveOrphanNodes();

        // --- Export (For Layer 2 Integration / Visualization) ---
        // Exports graph topology to CSV for external analysis
        // Format: NodeID, CentroidX, CentroidY, Neighbors(ID:Cost|ID:Cost...)
        void ExportGraphToCSV(const std::string& filename) const;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/NavMeshGenerator.hh <==
#ifndef BACKEND_LAYER1_NAVMESHGENERATOR_HH
#define BACKEND_LAYER1_NAVMESHGENERATOR_HH

#include "StaticBitMap.hh"
#include "NavMesh.hh"

namespace Backend {
namespace Layer1 {

    class NavMeshGenerator {
    public:
        /**
         * @brief The main factory method.
         * Reads the static grid, performs Recast/Decomposition, 
         * and populates the NavMesh object.
         * * @param map The input static bitmap (pixels)
         * @param mesh The output graph object to populate
         */
        void ComputeRecast(const StaticBitMap& map, NavMesh& mesh);
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/StaticBitMap.hh <==
#ifndef BACKEND_LAYER1_STATICBITMAP_HH
#define BACKEND_LAYER1_STATICBITMAP_HH

#include <vector>
#include <string>
#include "AbstractGrid.hh"

namespace Backend {
namespace Layer1 {

    class StaticBitMap : public AbstractGrid {
    private:
        // Flattened 2D grid: index = y * width + x
        std::vector<bool> gridData;

    public:
        // Default constructor for manual sizing
        StaticBitMap(int w, int h, Backend::Common::Resolution res);

        // Implement the contract
        bool IsAccessible(Backend::Common::Coordinates coords) const override;

        // Load map from file - reads dimensions from first line, then parses grid
        // '.' = walkable, '#' = obstacle
        void LoadFromFile(const std::string& filepath);
        
        // Used by DynamicBitMap to clone data
        const std::vector<bool>& GetRawData() const;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./main.cc <==
/**
 * =============================================================================
 * Layer 1 (Mapping) Integration Test Driver
 * =============================================================================
 * 
 * This test validates that the Layer 1 architecture holds together:
 * 1. Static Map Loading from file
 * 2. NavMesh Graph Generation
 * 3. Dynamic/Static isolation for Layer 2/3 separation
 * 
 * =============================================================================
 */

#include <iostream>
#include <cassert>
#include <string>

// Layer 1 includes
#include "StaticBitMap.hh"
#include "DynamicBitMap.hh"
#include "NavMesh.hh"
#include "NavMeshGenerator.hh"
#include "DynamicObstacleGenerator.hh"

// Common includes
#include "Coordinates.hh"
#include "Resolution.hh"

using namespace Backend::Layer1;
using namespace Backend::Common;

// =============================================================================
// ANSI Color Codes for test output
// =============================================================================
#define COLOR_RESET   "\033[0m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_RED     "\033[31m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_CYAN    "\033[36m"

void PrintHeader(const std::string& title) {
    std::cout << "\n" << COLOR_CYAN 
              << "======================================================\n"
              << "  " << title << "\n"
              << "======================================================"
              << COLOR_RESET << "\n\n";
}

void PrintPass(const std::string& test) {
    std::cout << COLOR_GREEN << "[PASS] " << COLOR_RESET << test << std::endl;
}

void PrintFail(const std::string& test) {
    std::cout << COLOR_RED << "[FAIL] " << COLOR_RESET << test << std::endl;
}

// =============================================================================
// MAIN TEST DRIVER
// =============================================================================
int main() {
    std::cout << "\n";
    std::cout << "╔═══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║     LAYER 1 (MAPPING) INTEGRATION TEST                        ║\n";
    std::cout << "║     Multi-Robot System - Backend Architecture Validation      ║\n";
    std::cout << "╚═══════════════════════════════════════════════════════════════╝\n";

    int totalTests = 0;
    int passedTests = 0;

    // =========================================================================
    // TEST 1: Static Map Loading
    // =========================================================================
    PrintHeader("TEST 1: Static Map Loading");

    // Create StaticBitMap with DECIMETERS resolution
    // 300x200 pixels @ DECIMETERS = 30m x 20m physical warehouse
    // 1m node = 10 px step size -> 30x20 = 600 max tiles
    StaticBitMap staticMap(300, 200, Resolution::DECIMETERS);
    
    try {
        staticMap.LoadFromFile("assets/map_layout.txt");
        PrintPass("StaticBitMap loaded from file successfully");
        passedTests++;
    } catch (const std::exception& e) {
        PrintFail("Failed to load StaticBitMap: " + std::string(e.what()));
    }
    totalTests++;

    // Verify dimensions
    auto dims = staticMap.GetDimensions();
    std::cout << "  Map dimensions: " << dims.first << " x " << dims.second << std::endl;
    
    if (dims.first > 0 && dims.second > 0) {
        PrintPass("Map has valid dimensions");
        passedTests++;
    } else {
        PrintFail("Map has invalid dimensions");
    }
    totalTests++;

    // =========================================================================
    // TEST 2: NavMesh Graph Generation
    // =========================================================================
    PrintHeader("TEST 2: NavMesh Graph Generation");

    NavMesh navMesh;
    NavMeshGenerator generator;
    
    generator.ComputeRecast(staticMap, navMesh);
    
    const auto& nodes = navMesh.GetAllNodes();
    std::cout << "  NavMesh nodes created: " << nodes.size() << std::endl;

    if (nodes.size() > 0) {
        PrintPass("NavMesh generated with " + std::to_string(nodes.size()) + " nodes");
        passedTests++;
    } else {
        PrintFail("NavMesh is empty - no nodes generated!");
    }
    totalTests++;

    // Verify we can lookup a node
    if (nodes.size() > 0) {
        int testNodeId = navMesh.GetNodeIdAt(nodes[0].coords);
        if (testNodeId >= 0) {
            PrintPass("Node lookup by coordinate works");
            passedTests++;
        } else {
            PrintFail("Node lookup failed");
        }
        totalTests++;
    }

    // =========================================================================
    // TEST 2b: NavMesh Graph Export (For Layer 2 / Visualization)
    // =========================================================================
    PrintHeader("TEST 2b: NavMesh Graph Export");

    try {
        navMesh.ExportGraphToCSV("assets/graph_dump.csv");
        PrintPass("NavMesh exported to assets/graph_dump.csv");
        passedTests++;
    } catch (const std::exception& e) {
        PrintFail("Failed to export NavMesh: " + std::string(e.what()));
    }
    totalTests++;

    // =========================================================================
    // TEST 3: Dynamic/Static Isolation (Critical for Layer 2/3 separation)
    // =========================================================================
    PrintHeader("TEST 3: Dynamic/Static Isolation");

    // Find a walkable coordinate for testing
    // Based on the map, (50, 50) should be in a walkable area
    Coordinates testCoord = {50, 50};
    
    // First, verify the test coordinate is walkable in the static map
    // If not, search for a walkable cell
    if (!staticMap.IsAccessible(testCoord)) {
        std::cout << "  Note: (50,50) is not walkable, searching for walkable cell...\n";
        bool found = false;
        for (int y = 3; y < dims.second - 3 && !found; ++y) {
            for (int x = 3; x < dims.first - 3 && !found; ++x) {
                if (staticMap.IsAccessible({x, y})) {
                    testCoord = {x, y};
                    found = true;
                }
            }
        }
        if (!found) {
            PrintFail("Could not find any walkable cell in the map!");
            return 1;
        }
    }
    
    std::cout << "  Test coordinate: (" << testCoord.x << ", " << testCoord.y << ")\n";

    // Verify it's walkable in static map
    bool staticAccessible = staticMap.IsAccessible(testCoord);
    std::cout << "  StaticBitMap.IsAccessible(" << testCoord.x << ", " << testCoord.y << "): " 
              << (staticAccessible ? "true" : "false") << std::endl;

    if (staticAccessible) {
        PrintPass("Test coordinate is accessible in StaticBitMap (Layer 2 view)");
        passedTests++;
    } else {
        PrintFail("Test coordinate should be accessible in StaticBitMap");
    }
    totalTests++;

    // Create DynamicBitMap from static
    DynamicBitMap dynamicMap(staticMap);

    // Verify it's initially also walkable in dynamic map
    bool dynamicAccessibleBefore = dynamicMap.IsAccessible(testCoord);
    std::cout << "  DynamicBitMap.IsAccessible (before obstacle): " 
              << (dynamicAccessibleBefore ? "true" : "false") << std::endl;

    if (dynamicAccessibleBefore) {
        PrintPass("DynamicBitMap initially matches StaticBitMap");
        passedTests++;
    } else {
        PrintFail("DynamicBitMap should initially match StaticBitMap");
    }
    totalTests++;

    // Create obstacle manager and spawn obstacle at test coordinate
    DynamicObstacleManager obstacleManager;
    obstacleManager.SpawnObstacleAt(testCoord, 1); // Size 1 obstacle

    std::cout << "  Spawned obstacle at (" << testCoord.x << ", " << testCoord.y << ")\n";

    // Update dynamic map with obstacles
    dynamicMap.Update(obstacleManager.GetActiveObstacles(), staticMap);

    // =======================================================================
    // CRITICAL ASSERTION: Verify Layer Isolation
    // =======================================================================
    bool staticAccessibleAfter = staticMap.IsAccessible(testCoord);
    bool dynamicAccessibleAfter = dynamicMap.IsAccessible(testCoord);

    std::cout << "\n" << COLOR_YELLOW << "  >>> CRITICAL ISOLATION TEST <<<" << COLOR_RESET << "\n";
    std::cout << "  StaticBitMap.IsAccessible (after obstacle spawn): " 
              << (staticAccessibleAfter ? "true" : "false") << std::endl;
    std::cout << "  DynamicBitMap.IsAccessible (after obstacle spawn): " 
              << (dynamicAccessibleAfter ? "true" : "false") << std::endl;

    // Static map MUST remain accessible (Layer 2 perspective - planning)
    if (staticAccessibleAfter) {
        PrintPass("StaticBitMap unchanged by dynamic obstacles (Layer 2 isolation OK)");
        passedTests++;
    } else {
        PrintFail("StaticBitMap was modified by dynamic obstacles - ISOLATION BROKEN!");
    }
    totalTests++;

    // Dynamic map MUST be blocked (Layer 3 perspective - real-time)
    if (!dynamicAccessibleAfter) {
        PrintPass("DynamicBitMap correctly blocked by obstacle (Layer 3 sees obstacles)");
        passedTests++;
    } else {
        PrintFail("DynamicBitMap not blocked - obstacle painting failed!");
    }
    totalTests++;

    // =======================================================================
    // FINAL ASSERTION: The layers are properly isolated
    // =======================================================================
    bool isolationValid = staticAccessibleAfter && !dynamicAccessibleAfter;
    
    std::cout << "\n";
    if (isolationValid) {
        std::cout << COLOR_GREEN 
                  << "  ✓ ASSERTION PASSED: Coordinate (" << testCoord.x << "," << testCoord.y 
                  << ") is Accessible in StaticBitMap but Blocked in DynamicBitMap"
                  << COLOR_RESET << "\n";
    } else {
        std::cout << COLOR_RED 
                  << "  ✗ ASSERTION FAILED: Layer isolation is broken!"
                  << COLOR_RESET << "\n";
    }

    // =========================================================================
    // TEST SUMMARY
    // =========================================================================
    std::cout << "\n";
    std::cout << "╔═══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                      TEST SUMMARY                             ║\n";
    std::cout << "╠═══════════════════════════════════════════════════════════════╣\n";
    
    if (passedTests == totalTests) {
        std::cout << "║  " << COLOR_GREEN << "ALL TESTS PASSED: " << passedTests << "/" << totalTests 
                  << COLOR_RESET << "                                        ║\n";
        std::cout << "║  " << COLOR_GREEN << "Layer 1 Architecture: VALIDATED" 
                  << COLOR_RESET << "                              ║\n";
    } else {
        std::cout << "║  " << COLOR_RED << "TESTS PASSED: " << passedTests << "/" << totalTests 
                  << COLOR_RESET << "                                         ║\n";
        std::cout << "║  " << COLOR_RED << "Some tests failed - review output above" 
                  << COLOR_RESET << "                  ║\n";
    }
    
    std::cout << "╚═══════════════════════════════════════════════════════════════╝\n\n";

    return (passedTests == totalTests) ? 0 : 1;
}

==> ./Makefile <==
# ==============================================================================
# Layer 1 (Mapping) Makefile
# ==============================================================================

# Compiler and Flags
CXX := g++
CXXFLAGS := -std=c++17 -Wall -Wextra -g

# Directories
LAYER1_DIR := .
COMMON_DIR := ../common
BUILD_DIR := build

# Include paths (flat structure)
INCLUDES := -I$(LAYER1_DIR)/include -I$(COMMON_DIR)/include

# Source files
LAYER1_SOURCES := $(wildcard $(LAYER1_DIR)/src/*.cc)
COMMON_SOURCES := $(wildcard $(COMMON_DIR)/src/*.cc)
MAIN_SOURCE := main.cc

# Object files (all go into build/)
LAYER1_OBJECTS := $(patsubst $(LAYER1_DIR)/src/%.cc,$(BUILD_DIR)/%.o,$(LAYER1_SOURCES))
COMMON_OBJECTS := $(patsubst $(COMMON_DIR)/src/%.cc,$(BUILD_DIR)/common_%.o,$(COMMON_SOURCES))
MAIN_OBJECT := $(BUILD_DIR)/main.o

ALL_OBJECTS := $(LAYER1_OBJECTS) $(COMMON_OBJECTS) $(MAIN_OBJECT)

# Target executable (inside build directory)
TARGET := test_layer1

# ==============================================================================
# Rules
# ==============================================================================

.PHONY: all clean run

all: $(BUILD_DIR) $(BUILD_DIR)/$(TARGET)

# Create build directory if it doesn't exist
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# Link all objects into executable (output in build/)
$(BUILD_DIR)/$(TARGET): $(ALL_OBJECTS)
	$(CXX) $(CXXFLAGS) -o $@ $^ -pthread

# Compile layer1 source files
$(BUILD_DIR)/%.o: $(LAYER1_DIR)/src/%.cc | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Compile common source files (with prefix to avoid name collision)
$(BUILD_DIR)/common_%.o: $(COMMON_DIR)/src/%.cc | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Compile main.cc
$(BUILD_DIR)/main.o: $(MAIN_SOURCE) | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Run the test executable
run: $(BUILD_DIR)/$(TARGET)
	./$(BUILD_DIR)/$(TARGET)

# Clean build artifacts
clean:
	rm -rf $(BUILD_DIR)

# ==============================================================================
# Debug: Print variables
# ==============================================================================
.PHONY: debug
debug:
	@echo "LAYER1_SOURCES: $(LAYER1_SOURCES)"
	@echo "COMMON_SOURCES: $(COMMON_SOURCES)"
	@echo "LAYER1_OBJECTS: $(LAYER1_OBJECTS)"
	@echo "COMMON_OBJECTS: $(COMMON_OBJECTS)"
	@echo "ALL_OBJECTS: $(ALL_OBJECTS)"
	@echo "TARGET: $(BUILD_DIR)/$(TARGET)"

==> ./src/AbstractGrid.cc <==
#include "AbstractGrid.hh"

namespace Backend {
namespace Layer1 {

    AbstractGrid::AbstractGrid(int w, int h, Backend::Common::Resolution res)
        : width(w), height(h), resolution(res) {}

    std::pair<int, int> AbstractGrid::GetDimensions() const {
        return {width, height};
    }

    Backend::Common::Resolution AbstractGrid::GetResolution() const {
        return resolution;
    }

    bool AbstractGrid::IsWithinBounds(Backend::Common::Coordinates coords) const {
        return coords.x >= 0 && coords.x < width && 
               coords.y >= 0 && coords.y < height;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/DynamicBitMap.cc <==
#include "DynamicBitMap.hh"

namespace Backend {
namespace Layer1 {

    DynamicBitMap::DynamicBitMap(const StaticBitMap& source)
        : AbstractGrid(source.GetDimensions().first, source.GetDimensions().second, Backend::Common::Resolution::METERS) {
        
        activeGrid = source.GetRawData();
    }

    bool DynamicBitMap::IsAccessible(Backend::Common::Coordinates coords) const {
        // LOCK READ
        std::lock_guard<std::mutex> lock(mapMutex);

        if (!IsWithinBounds(coords)) return false;
        return activeGrid[coords.y * width + coords.x];
    }

    void DynamicBitMap::Update(const std::vector<DynamicObstacle>& obstacles, const StaticBitMap& source) {
        // LOCK WRITE
        std::lock_guard<std::mutex> lock(mapMutex);

        // 1. Wipe Canvas (Reset to Static)
        activeGrid = source.GetRawData();

        // 2. Paint Obstacles
        for (const auto& obs : obstacles) {
            for (const auto& cell : obs.GetOccupiedCells()) {
                if (IsWithinBounds(cell)) {
                    activeGrid[cell.y * width + cell.x] = false;
                }
            }
        }
    }

} // namespace Layer1
} // namespace Backend
==> ./src/DynamicObstacle.cc <==
#include "DynamicObstacle.hh"

namespace Backend {
namespace Layer1 {

    DynamicObstacle::DynamicObstacle(Backend::Common::Coordinates anchor, int s)
        : size(s), top_left_anchor(anchor) {}

    std::vector<Backend::Common::Coordinates> DynamicObstacle::GetOccupiedCells() const {
        std::vector<Backend::Common::Coordinates> cells;
        cells.reserve(size * size); 

        for (int x = 0; x < size; ++x) {
            for (int y = 0; y < size; ++y) {
                cells.push_back({
                    top_left_anchor.x + x,
                    top_left_anchor.y + y
                });
            }
        }
        return cells;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/DynamicObstacleGenerator.cc <==
#include "DynamicObstacleGenerator.hh"
#include <cstdlib> // rand
#include <ctime>   // time

namespace Backend {
namespace Layer1 {

    void DynamicObstacleManager::SpawnRandomObstacle(int mapWidth, int mapHeight) {
        int size = (std::rand() % 3) + 1; // Random size 1-3
        
        int maxX = mapWidth - size;
        int maxY = mapHeight - size;

        if (maxX <= 0 || maxY <= 0) return; 

        int x = std::rand() % maxX;
        int y = std::rand() % maxY;

        active_obstacles.emplace_back(Backend::Common::Coordinates{x, y}, size);
    }

    void DynamicObstacleManager::SpawnObstacleAt(Backend::Common::Coordinates coords, int size) {
        active_obstacles.emplace_back(coords, size);
    }

    const std::vector<DynamicObstacle>& DynamicObstacleManager::GetActiveObstacles() const {
        return active_obstacles;
    }

    void DynamicObstacleManager::Clear() {
        active_obstacles.clear();
    }

} // namespace Layer1
} // namespace Backend
==> ./src/NavMesh.cc <==
#include "NavMesh.hh"
#include <cmath>
#include <limits>
#include <fstream>
#include <iostream>
#include <sstream>

namespace Backend {
namespace Layer1 {

    NavMesh::NavMesh() {}

    const std::vector<Backend::Common::Node>& NavMesh::GetAllNodes() const {
        return allNodes;
    }

    const std::vector<Backend::Common::Edge>& NavMesh::GetNeighbors(int nodeId) const {
        if (nodeId < 0 || nodeId >= (int)adjacencyList.size()) {
            static const std::vector<Backend::Common::Edge> empty;
            return empty;
        }
        return adjacencyList[nodeId];
    }

    int NavMesh::GetNodeIdAt(Backend::Common::Coordinates coords) const {
        // Naive implementation: Linear Search for nearest centroid.
        // OPTIMIZATION: In production, use a Spatial Hash, QuadTree, or 2D Grid Lookup.
        
        int bestNode = -1;
        float minDist = std::numeric_limits<float>::max();

        for (int i = 0; i < (int)allNodes.size(); ++i) {
            float dist = coords.DistanceTo(allNodes[i].coords);
            
            // Simple threshold: If we are close enough to a node center
            // (You might want strict polygon containment checks here later)
            if (dist < minDist) {
                minDist = dist;
                bestNode = i;
            }
        }
        
        // Threshold check (e.g., must be within 5 units of a node)
        // if (minDist > 5.0f) return -1; 

        return bestNode;
    }

    void NavMesh::AddNode(Backend::Common::Coordinates centroid) {
        Backend::Common::Node n;
        n.coords = centroid;
        allNodes.push_back(n);
        
        // Resize adjacency list to match node count
        adjacencyList.resize(allNodes.size());
    }

    void NavMesh::AddEdge(int sourceId, int targetId, float cost) {
        if (sourceId >= 0 && sourceId < (int)adjacencyList.size()) {
            Backend::Common::Edge e;
            e.targetNodeId = targetId;
            e.cost = cost;
            adjacencyList[sourceId].push_back(e);
        }
    }

    int NavMesh::RemoveOrphanNodes() {
        if (allNodes.empty()) return 0;
        
        // Use BFS to find all nodes reachable from node 0 (the main connected component)
        std::vector<bool> reachable(allNodes.size(), false);
        std::vector<int> queue;
        
        // Start BFS from node 0
        queue.push_back(0);
        reachable[0] = true;
        
        while (!queue.empty()) {
            int current = queue.back();
            queue.pop_back();
            
            // Visit all neighbors
            if (current < (int)adjacencyList.size()) {
                for (const auto& edge : adjacencyList[current]) {
                    if (edge.targetNodeId >= 0 && 
                        edge.targetNodeId < (int)reachable.size() &&
                        !reachable[edge.targetNodeId]) {
                        reachable[edge.targetNodeId] = true;
                        queue.push_back(edge.targetNodeId);
                    }
                }
            }
        }
        
        // Count unreachable nodes and build mapping from old ID to new ID
        std::vector<int> oldToNew(allNodes.size(), -1);
        int newId = 0;
        int orphanCount = 0;
        
        for (size_t i = 0; i < reachable.size(); ++i) {
            if (reachable[i]) {
                oldToNew[i] = newId++;
            } else {
                orphanCount++;
            }
        }
        
        if (orphanCount == 0) {
            return 0;  // No orphans to remove
        }
        
        // Build new node list (only reachable nodes)
        std::vector<Backend::Common::Node> newNodes;
        newNodes.reserve(newId);
        for (size_t i = 0; i < allNodes.size(); ++i) {
            if (oldToNew[i] != -1) {
                newNodes.push_back(allNodes[i]);
            }
        }
        
        // Build new adjacency list with remapped IDs
        std::vector<std::vector<Backend::Common::Edge>> newAdjList(newId);
        for (size_t i = 0; i < adjacencyList.size(); ++i) {
            if (oldToNew[i] != -1) {
                for (const auto& edge : adjacencyList[i]) {
                    if (oldToNew[edge.targetNodeId] != -1) {
                        Backend::Common::Edge newEdge;
                        newEdge.targetNodeId = oldToNew[edge.targetNodeId];
                        newEdge.cost = edge.cost;
                        newAdjList[oldToNew[i]].push_back(newEdge);
                    }
                }
            }
        }
        
        // Replace with cleaned data
        allNodes = std::move(newNodes);
        adjacencyList = std::move(newAdjList);
        
        return orphanCount;
    }

    void NavMesh::ExportGraphToCSV(const std::string& filename) const {
        std::ofstream file(filename);
        if (!file.is_open()) {
            std::cerr << "[NavMesh] ERROR: Failed to open file for export: " << filename << std::endl;
            return;
        }

        // Write header comment
        file << "# NavMesh Graph Export\n";
        file << "# Format: NodeID, CentroidX, CentroidY, Neighbors(ID:Cost|ID:Cost...)\n";

        // Export each node with its neighbors
        for (size_t nodeId = 0; nodeId < allNodes.size(); ++nodeId) {
            const auto& node = allNodes[nodeId];
            
            // Write NodeID, CentroidX, CentroidY
            file << nodeId << ", " << node.coords.x << ", " << node.coords.y << ", ";
            
            // Write neighbors
            if (nodeId < adjacencyList.size()) {
                const auto& neighbors = adjacencyList[nodeId];
                for (size_t i = 0; i < neighbors.size(); ++i) {
                    file << neighbors[i].targetNodeId << ":" << neighbors[i].cost;
                    if (i < neighbors.size() - 1) {
                        file << "|";
                    }
                }
            }
            
            file << "\n";
        }

        file.close();
        std::cout << "[NavMesh] Exported " << allNodes.size() << " nodes to: " << filename << std::endl;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/NavMeshGenerator.cc <==
// layer1/src/NavMeshGenerator.cc

#include "NavMeshGenerator.hh"
#include "Resolution.hh"
#include <vector>
#include <cmath>
#include <iostream>
#include <unordered_map>

namespace Backend {
namespace Layer1 {

    // =========================================================================
    // CONFIGURATION
    // =========================================================================
    // The physical size of one graph node (robot footprint)
    // Robot is 60cm x 60cm = 0.6m x 0.6m
    constexpr float TARGET_NODE_SIZE_METERS = 0.6f;

    // =========================================================================
    // HELPER: Get step size in pixels based on resolution
    // =========================================================================
    static int GetStepSize(Backend::Common::Resolution res) {
        switch (res) {
            case Backend::Common::Resolution::METERS:
                // 1 pixel = 1 meter -> step = 1 pixel per 1m node
                return static_cast<int>(TARGET_NODE_SIZE_METERS * 1.0f);
            case Backend::Common::Resolution::DECIMETERS:
                // 1 pixel = 0.1 meter -> step = 10 pixels per 1m node
                return static_cast<int>(TARGET_NODE_SIZE_METERS * 10.0f);
            case Backend::Common::Resolution::CENTIMETERS:
                // 1 pixel = 0.01 meter -> step = 100 pixels per 1m node
                return static_cast<int>(TARGET_NODE_SIZE_METERS * 100.0f);
            case Backend::Common::Resolution::MILLIMETERS:
                // 1 pixel = 0.001 meter -> step = 1000 pixels per 1m node
                return static_cast<int>(TARGET_NODE_SIZE_METERS * 1000.0f);
            default:
                return 1;
        }
    }

    // =========================================================================
    // HELPER: Check if a tile is FULLY accessible (all pixels must be walkable)
    // AND if a robot can actually reach it (check clearance in all 4 directions)
    // =========================================================================
    static bool IsTileAccessible(const StaticBitMap& map, int tileX, int tileY, int stepSize) {
        auto dims = map.GetDimensions();
        int mapW = dims.first;
        int mapH = dims.second;
        
        // Check ALL pixels within the tile
        for (int dy = 0; dy < stepSize; ++dy) {
            for (int dx = 0; dx < stepSize; ++dx) {
                int px = tileX + dx;
                int py = tileY + dy;
                
                // Bounds check
                if (px >= mapW || py >= mapH) {
                    return false;
                }
                
                // If ANY pixel is an obstacle, tile is not accessible
                if (!map.IsAccessible({px, py})) {
                    return false;
                }
            }
        }
        
        // Additional check: Can a robot actually REACH this tile?
        // The robot needs at least ONE direction where it can approach with full clearance
        // Check if there's clearance to move INTO this tile from at least one cardinal direction
        
        bool canReachFromLeft = true;
        bool canReachFromRight = true;
        bool canReachFromTop = true;
        bool canReachFromBottom = true;
        
        // Check LEFT approach (robot moving from left needs corridor of stepSize width)
        if (tileX >= stepSize) {
            for (int dy = 0; dy < stepSize; ++dy) {
                for (int dx = -stepSize; dx < stepSize; ++dx) {
                    int px = tileX + dx;
                    int py = tileY + dy;
                    if (px < 0 || px >= mapW || py < 0 || py >= mapH || !map.IsAccessible({px, py})) {
                        canReachFromLeft = false;
                        break;
                    }
                }
                if (!canReachFromLeft) break;
            }
        } else {
            canReachFromLeft = false;
        }
        
        // Check RIGHT approach
        if (tileX + 2 * stepSize <= mapW) {
            for (int dy = 0; dy < stepSize; ++dy) {
                for (int dx = 0; dx < 2 * stepSize; ++dx) {
                    int px = tileX + dx;
                    int py = tileY + dy;
                    if (px >= mapW || py >= mapH || !map.IsAccessible({px, py})) {
                        canReachFromRight = false;
                        break;
                    }
                }
                if (!canReachFromRight) break;
            }
        } else {
            canReachFromRight = false;
        }
        
        // Check TOP approach
        if (tileY >= stepSize) {
            for (int dx = 0; dx < stepSize; ++dx) {
                for (int dy = -stepSize; dy < stepSize; ++dy) {
                    int px = tileX + dx;
                    int py = tileY + dy;
                    if (px >= mapW || py < 0 || py >= mapH || !map.IsAccessible({px, py})) {
                        canReachFromTop = false;
                        break;
                    }
                }
                if (!canReachFromTop) break;
            }
        } else {
            canReachFromTop = false;
        }
        
        // Check BOTTOM approach
        if (tileY + 2 * stepSize <= mapH) {
            for (int dx = 0; dx < stepSize; ++dx) {
                for (int dy = 0; dy < 2 * stepSize; ++dy) {
                    int px = tileX + dx;
                    int py = tileY + dy;
                    if (px >= mapW || py >= mapH || !map.IsAccessible({px, py})) {
                        canReachFromBottom = false;
                        break;
                    }
                }
                if (!canReachFromBottom) break;
            }
        } else {
            canReachFromBottom = false;
        }
        
        // Tile is only accessible if robot can reach it from at least ONE direction
        return canReachFromLeft || canReachFromRight || canReachFromTop || canReachFromBottom;
    }

    // =========================================================================
    // HELPER: Check if a robot can pass between two adjacent tiles
    // The ENTIRE robot body (stepSize x stepSize) must fit through the passage
    // =========================================================================
    static bool CanRobotPassBetween(const StaticBitMap& map, 
                                     int tile1X, int tile1Y, 
                                     int tile2X, int tile2Y, 
                                     int stepSize) {
        auto dims = map.GetDimensions();
        int mapW = dims.first;
        int mapH = dims.second;
        
        // Both tiles are already verified to be fully walkable
        // Now check if the robot can physically move between them
        
        // The robot occupies stepSize x stepSize during the entire movement
        // We need to verify ALL pixels the robot sweeps through
        
        int dx = tile2X - tile1X;  // +stepSize = moving right, -stepSize = moving left
        int dy = tile2Y - tile1Y;  // +stepSize = moving down, -stepSize = moving up
        
        if (dx != 0) {
            // Horizontal movement (left/right)
            // The robot sweeps a rectangle from tile1 to tile2
            int minX = std::min(tile1X, tile2X);
            int maxX = std::max(tile1X, tile2X) + stepSize;
            
            // Check the entire swept area (height = stepSize, width = 2*stepSize)
            for (int y = tile1Y; y < tile1Y + stepSize; ++y) {
                for (int x = minX; x < maxX; ++x) {
                    if (x < 0 || x >= mapW || y < 0 || y >= mapH) {
                        return false;
                    }
                    if (!map.IsAccessible({x, y})) {
                        return false;
                    }
                }
            }
        } else if (dy != 0) {
            // Vertical movement (up/down)
            // The robot sweeps a rectangle from tile1 to tile2
            int minY = std::min(tile1Y, tile2Y);
            int maxY = std::max(tile1Y, tile2Y) + stepSize;
            
            // Check the entire swept area (width = stepSize, height = 2*stepSize)
            for (int y = minY; y < maxY; ++y) {
                for (int x = tile1X; x < tile1X + stepSize; ++x) {
                    if (x < 0 || x >= mapW || y < 0 || y >= mapH) {
                        return false;
                    }
                    if (!map.IsAccessible({x, y})) {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }

    // =========================================================================
    // MAIN COMPUTE FUNCTION - UNIFORM TILING
    // =========================================================================
    void NavMeshGenerator::ComputeRecast(const StaticBitMap& map, NavMesh& mesh) {
        auto dims = map.GetDimensions();
        int mapW = dims.first;
        int mapH = dims.second;
        
        Backend::Common::Resolution resolution = map.GetResolution();
        int stepSize = GetStepSize(resolution);

        std::cout << "[NavMeshGenerator] Starting Uniform Tiling..." << std::endl;
        std::cout << "[NavMeshGenerator] Map: " << mapW << "x" << mapH << " pixels" << std::endl;
        std::cout << "[NavMeshGenerator] Resolution: ";
        switch (resolution) {
            case Backend::Common::Resolution::METERS: std::cout << "METERS"; break;
            case Backend::Common::Resolution::DECIMETERS: std::cout << "DECIMETERS"; break;
            case Backend::Common::Resolution::CENTIMETERS: std::cout << "CENTIMETERS"; break;
            case Backend::Common::Resolution::MILLIMETERS: std::cout << "MILLIMETERS"; break;
        }
        std::cout << " (Step Size: " << stepSize << " pixels = " << TARGET_NODE_SIZE_METERS << "m)" << std::endl;

        // Calculate expected grid dimensions in tiles
        int tilesX = mapW / stepSize;
        int tilesY = mapH / stepSize;
        std::cout << "[NavMeshGenerator] Expected Grid: " << tilesX << "x" << tilesY 
                  << " = " << (tilesX * tilesY) << " max tiles" << std::endl;

        // =====================================================================
        // PHASE 1: Create Nodes (Uniform Grid Sampling)
        // =====================================================================
        // Map from (tileGridX, tileGridY) -> nodeId for edge creation
        std::unordered_map<int, int> tileToNodeId;
        
        auto getTileKey = [tilesX](int gx, int gy) -> int {
            return gy * tilesX + gx;
        };

        int nodeIdCounter = 0;
        
        for (int tileGridY = 0; tileGridY < tilesY; ++tileGridY) {
            for (int tileGridX = 0; tileGridX < tilesX; ++tileGridX) {
                // Calculate pixel coordinates of tile's top-left
                int pixelX = tileGridX * stepSize;
                int pixelY = tileGridY * stepSize;
                
                // Check if tile is accessible
                if (IsTileAccessible(map, pixelX, pixelY, stepSize)) {
                    // Create node at tile center
                    int centerX = pixelX + stepSize / 2;
                    int centerY = pixelY + stepSize / 2;
                    
                    mesh.AddNode({centerX, centerY});
                    tileToNodeId[getTileKey(tileGridX, tileGridY)] = nodeIdCounter;
                    ++nodeIdCounter;
                }
            }
        }

        std::cout << "[NavMeshGenerator] Created " << nodeIdCounter << " nodes (tiles)" << std::endl;

        // =====================================================================
        // PHASE 2: Create Edges (4-Connected Neighbors with Robot Clearance Check)
        // =====================================================================
        int edgeCount = 0;
        
        // Direction offsets for 4-connectivity
        const int dx[] = {1, 0, -1, 0};  // Right, Down, Left, Up
        const int dy[] = {0, 1, 0, -1};
        
        for (int tileGridY = 0; tileGridY < tilesY; ++tileGridY) {
            for (int tileGridX = 0; tileGridX < tilesX; ++tileGridX) {
                int currentKey = getTileKey(tileGridX, tileGridY);
                
                // Skip if this tile has no node
                auto currentIt = tileToNodeId.find(currentKey);
                if (currentIt == tileToNodeId.end()) continue;
                
                int currentNodeId = currentIt->second;
                
                // Pixel coordinates of current tile
                int currentPixelX = tileGridX * stepSize;
                int currentPixelY = tileGridY * stepSize;
                
                // Check all 4 neighbors
                for (int d = 0; d < 4; ++d) {
                    int neighborGridX = tileGridX + dx[d];
                    int neighborGridY = tileGridY + dy[d];
                    
                    // Bounds check
                    if (neighborGridX < 0 || neighborGridX >= tilesX ||
                        neighborGridY < 0 || neighborGridY >= tilesY) {
                        continue;
                    }
                    
                    int neighborKey = getTileKey(neighborGridX, neighborGridY);
                    auto neighborIt = tileToNodeId.find(neighborKey);
                    
                    if (neighborIt != tileToNodeId.end()) {
                        int neighborNodeId = neighborIt->second;
                        
                        // Pixel coordinates of neighbor tile
                        int neighborPixelX = neighborGridX * stepSize;
                        int neighborPixelY = neighborGridY * stepSize;
                        
                        // Only add edge in one direction to avoid double-counting
                        if (currentNodeId < neighborNodeId) {
                            // CHECK: Can a robot actually pass between these tiles?
                            if (CanRobotPassBetween(map, currentPixelX, currentPixelY,
                                                    neighborPixelX, neighborPixelY, stepSize)) {
                                // Cost = Euclidean distance = stepSize for cardinal directions
                                float cost = static_cast<float>(stepSize);
                                
                                // Add bi-directional edges
                                mesh.AddEdge(currentNodeId, neighborNodeId, cost);
                                mesh.AddEdge(neighborNodeId, currentNodeId, cost);
                                ++edgeCount;
                            }
                        }
                    }
                }
            }
        }

        std::cout << "[NavMeshGenerator] Created " << edgeCount << " edges (bi-directional)" << std::endl;
        
        // =====================================================================
        // PHASE 3: Remove Orphan Nodes (nodes with no edges - unreachable)
        // =====================================================================
        int orphansRemoved = mesh.RemoveOrphanNodes();
        if (orphansRemoved > 0) {
            std::cout << "[NavMeshGenerator] Removed " << orphansRemoved << " unreachable nodes" << std::endl;
        }
        
        // Calculate physical dimensions for verification
        float physicalW = mapW * Backend::Common::GetConversionFactorToMeters(resolution);
        float physicalH = mapH * Backend::Common::GetConversionFactorToMeters(resolution);
        std::cout << "[NavMeshGenerator] Physical Map Size: " << physicalW << "m x " << physicalH << "m" << std::endl;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/StaticBitMap.cc <==
#include "StaticBitMap.hh"
#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>

namespace Backend {
namespace Layer1 {

    StaticBitMap::StaticBitMap(int w, int h, Backend::Common::Resolution res)
        : AbstractGrid(w, h, res) {
        // Initialize all true (walkable)
        gridData.resize(w * h, true);
    }

    bool StaticBitMap::IsAccessible(Backend::Common::Coordinates coords) const {
        if (!IsWithinBounds(coords)) return false;
        return gridData[coords.y * width + coords.x];
    }

    void StaticBitMap::LoadFromFile(const std::string& filepath) {
        std::cout << "[StaticBitMap] Loading map layout from: " << filepath << std::endl;
        
        std::ifstream file(filepath);
        if (!file.is_open()) {
            throw std::runtime_error("[StaticBitMap] Failed to open file: " + filepath);
        }

        // Read dimensions from first line
        int fileWidth, fileHeight;
        file >> fileWidth >> fileHeight;
        file.ignore(); // Skip the newline after dimensions

        if (fileWidth != width || fileHeight != height) {
            std::cout << "[StaticBitMap] Warning: File dimensions (" << fileWidth << "x" << fileHeight 
                      << ") differ from initialized dimensions (" << width << "x" << height << ")." << std::endl;
            // Resize to match file
            width = fileWidth;
            height = fileHeight;
            gridData.resize(width * height, true);
        }

        // Read the grid data row by row
        std::string line;
        int y = 0;
        while (std::getline(file, line) && y < height) {
            for (int x = 0; x < width && x < (int)line.size(); ++x) {
                char c = line[x];
                // '.' = walkable (true), '#' = obstacle (false)
                gridData[y * width + x] = (c == '.');
            }
            ++y;
        }

        file.close();
        
        // Count walkable cells for stats
        int walkable = 0;
        for (bool cell : gridData) {
            if (cell) walkable++;
        }
        
        std::cout << "[StaticBitMap] Loaded " << width << "x" << height << " map. "
                  << "Walkable cells: " << walkable << " / " << (width * height) << std::endl;
    }

    const std::vector<bool>& StaticBitMap::GetRawData() const {
        return gridData;
    }

} // namespace Layer1
} // namespace Backend
==> ./utils/map_baker.py <==
from PIL import Image
import sys
import os

def parse_dimensions(dim_str):
    """Parses a string like '30x20' into tuple (30.0, 20.0)."""
    try:
        # Normalize to lowercase 'x'
        parts = dim_str.lower().split('x')
        if len(parts) != 2:
            raise ValueError
        width = float(parts[0])
        height = float(parts[1])
        return width, height
    except ValueError:
        print(f"Error: Invalid dimension format '{dim_str}'. Expected format: WIDTHxHEIGHT (e.g., 30x20)")
        sys.exit(1)

def convert_png_to_grid(input_path, output_path, physical_dims, threshold=128):
    try:
        # 1. Load Image
        if not os.path.exists(input_path):
            print(f"Error: File {input_path} not found.")
            return

        original_img = Image.open(input_path)
        original_img = original_img.convert('L') # Grayscale
        
        real_w_meters, real_h_meters = physical_dims

        print(f"\n--- MAP CONFIGURATION ---")
        print(f"Input Image:      {input_path}")
        print(f"Physical Size:    {real_w_meters}m (Width) x {real_h_meters}m (Height)")
        print(f"Physical Area:    {real_w_meters * real_h_meters} m^2")

        # 2. Define Options based on Backend::Common::Resolution
        # Multiplier = Cells per meter
        options = {
            1: ("METERS", 1.0),         # 1 cell = 1m
            2: ("DECIMETERS", 10.0),    # 1 cell = 0.1m (10 cells/m)
            3: ("CENTIMETERS", 100.0),  # 1 cell = 0.01m
            4: ("MILLIMETERS", 1000.0)  # 1 cell = 0.001m
        }

        print("\n--- SELECT RESOLUTION ---")
        # Header
        print(f"{'Opt':<5} {'Name':<15} {'Grid Size (WxH)':<20} {'Total Cells'}")
        print("-" * 60)

        # Calculate and display grid sizes for each option
        for key, (name, multiplier) in options.items():
            grid_w = int(real_w_meters * multiplier)
            grid_h = int(real_h_meters * multiplier)
            total = grid_w * grid_h
            
            warning = " (!! HEAVY !!)" if total > 10000000 else ""
            print(f"{key:<5} {name:<15} {grid_w}x{grid_h:<15} {total}{warning}")

        # 3. Get User Selection
        try:
            choice_str = input("\nSelect Option (1-4): ")
            choice = int(choice_str)
            if choice not in options:
                print("Invalid option.")
                return
        except ValueError:
            print("Invalid input.")
            return

        selected_name, multiplier = options[choice]
        
        # Final Grid Calculation
        target_w = int(real_w_meters * multiplier)
        target_h = int(real_h_meters * multiplier)

        print(f"\nProcessing as {selected_name}...")
        print(f"Resizing image to grid dimensions: {target_w}x{target_h}...")

        # 4. Resize Image (LANCZOS for quality)
        # This implicitly handles aspect ratio distortion if your PNG doesn't match your meters.
        # e.g. If PNG is square but meters are 30x10, the image will stretch to fit 30x10.
        
        resized_img = original_img.resize((target_w, target_h), Image.Resampling.LANCZOS)
        
        pixels = list(resized_img.getdata())

        # 5. Write to Text File
        with open(output_path, 'w') as f:
            # Header: Width Height
            f.write(f"{target_w} {target_h}\n")
            
            # Grid Data
            for y in range(target_h):
                row_str = ""
                for x in range(target_w):
                    pixel_val = pixels[y * target_w + x]
                    
                    # LOGIC: Dark = Wall (#), Light = Floor (.)
                    if pixel_val < threshold:
                        row_str += "#"
                    else:
                        row_str += "."
                
                f.write(row_str + "\n")
                
        print(f"\nSUCCESS! Map saved to: {output_path}")
        print(f"Grid Dimensions: {target_w} x {target_h}")

    except Exception as e:
        print(f"Critical Error: {e}")

if __name__ == "__main__":
    # Usage Check
    if len(sys.argv) < 4:
        print("Usage: python3 map_baker.py <input_png> <output_txt> <WxH_meters>")
        print("Example: python3 utils/map_baker.py warehouse.png map.txt 30x20")
    else:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        dimensions = parse_dimensions(sys.argv[3])
        
        convert_png_to_grid(input_file, output_file, dimensions)