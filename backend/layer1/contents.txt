.
├── Makefile
├── include
│   ├── AbstractGrid.hh
│   ├── DynamicBitMap.hh
│   ├── DynamicObstacle.hh
│   ├── DynamicObstacleGenerator.hh
│   ├── NavMesh.hh
│   ├── NavMeshGenerator.hh
│   └── StaticBitMap.hh
├── main.cc
├── src
│   ├── AbstractGrid.cc
│   ├── DynamicBitMap.cc
│   ├── DynamicObstacle.cc
│   ├── DynamicObstacleGenerator.cc
│   ├── NavMesh.cc
│   ├── NavMeshGenerator.cc
│   └── StaticBitMap.cc
└── utils
    └── map_baker.py

3 directories, 17 files


================ FILE CONTENTS ================

==> ./include/AbstractGrid.hh <==
#ifndef BACKEND_LAYER1_ABSTRACTGRID_HH
#define BACKEND_LAYER1_ABSTRACTGRID_HH

#include <utility> 
#include "Coordinates.hh"
#include "Resolution.hh" 

namespace Backend {
namespace Layer1 {

    class AbstractGrid {
    protected:
        int width;
        int height;
        Backend::Common::Resolution resolution;

    public:
        AbstractGrid(int w, int h, Backend::Common::Resolution res);

        // Virtual Destructor is REQUIRED for inheritance safety
        virtual ~AbstractGrid() = default;

        std::pair<int, int> GetDimensions() const;
        
        bool IsWithinBounds(Backend::Common::Coordinates coords) const;

        // The Pure Virtual Contract
        virtual bool IsAccessible(Backend::Common::Coordinates coords) const = 0;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/DynamicBitMap.hh <==
#ifndef BACKEND_LAYER1_DYNAMICBITMAP_HH
#define BACKEND_LAYER1_DYNAMICBITMAP_HH

#include <vector>
#include <mutex>
#include "AbstractGrid.hh"
#include "StaticBitMap.hh"
#include "DynamicObstacle.hh"

namespace Backend {
namespace Layer1 {

    class DynamicBitMap : public AbstractGrid {
    private:
        std::vector<bool> activeGrid;
        
        // Critical for Layer 3 (Reading) vs Layer 1 (Writing) safety
        mutable std::mutex mapMutex; 

    public:
        // Constructor copies the static map initially
        explicit DynamicBitMap(const StaticBitMap& source);

        bool IsAccessible(Backend::Common::Coordinates coords) const override;

        // The Update Loop
        // We use the Static Map to "Reset" the canvas, then paint obstacles
        void Update(const std::vector<DynamicObstacle>& obstacles, const StaticBitMap& source);
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/DynamicObstacle.hh <==
#ifndef BACKEND_LAYER1_DYNAMICOBSTACLE_HH
#define BACKEND_LAYER1_DYNAMICOBSTACLE_HH

#include <vector>
#include "Coordinates.hh"

namespace Backend {
namespace Layer1 {

    class DynamicObstacle {
    private:
        int size; 
        Backend::Common::Coordinates top_left_anchor;

    public:
        DynamicObstacle(Backend::Common::Coordinates anchor, int s);

        std::vector<Backend::Common::Coordinates> GetOccupiedCells() const;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/DynamicObstacleGenerator.hh <==
#ifndef BACKEND_LAYER1_DYNAMICOBSTACLEMANAGER_HH
#define BACKEND_LAYER1_DYNAMICOBSTACLEMANAGER_HH

#include <vector>
#include "DynamicObstacle.hh"

namespace Backend {
namespace Layer1 {

    class DynamicObstacleManager {
    private:
        std::vector<DynamicObstacle> active_obstacles;

    public:
        // Spawns a new obstacle within the given map bounds
        void SpawnRandomObstacle(int mapWidth, int mapHeight);
        
        // Spawns an obstacle at a specific location with given size
        void SpawnObstacleAt(Backend::Common::Coordinates coords, int size);

        const std::vector<DynamicObstacle>& GetActiveObstacles() const;
        
        void Clear();
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/NavMesh.hh <==
#ifndef BACKEND_LAYER1_NAVMESH_HH
#define BACKEND_LAYER1_NAVMESH_HH

#include <vector>
#include "Coordinates.hh" // From common

// Since Node and Edge are simple structs defined in Common, we use them here.
// Ideally, create Node.hh and Edge.hh in Common, or define them here if specific to NavMesh.
// Based on your UML, they seem to be in Common/Shared Types.
// Assuming they are defined in a file like "GraphTypes.hh" or similar in common.
// For this implementation, I will define local structs if they aren't in common yet, 
// but based on your architecture, they should be imported.

namespace Backend {
namespace Common {
    // Re-declaring for context (remove if included via header)
    struct Node {
        Coordinates coords;
    };
    
    struct Edge {
        int targetNodeId;
        float cost;
    };
}

namespace Layer1 {

    class NavMesh {
    private:
        // The Nodes (Polygons/Centroids)
        std::vector<Backend::Common::Node> allNodes;

        // Adjacency List: Index = Source Node ID, Value = List of Edges
        std::vector<std::vector<Backend::Common::Edge>> adjacencyList;

    public:
        // Constructor
        NavMesh();

        // --- Graph Accessors ---
        const std::vector<Backend::Common::Node>& GetAllNodes() const;
        const std::vector<Backend::Common::Edge>& GetNeighbors(int nodeId) const;

        // --- Geometry Lookups ---
        
        // Converts a world coordinate (x,y) to the nearest NavMesh Node ID.
        // Returns -1 if not accessible or out of bounds.
        int GetNodeIdAt(Backend::Common::Coordinates coords) const;

        // --- Modifiers (Used by Generator) ---
        void AddNode(Backend::Common::Coordinates centroid);
        void AddEdge(int sourceId, int targetId, float cost);
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/NavMeshGenerator.hh <==
#ifndef BACKEND_LAYER1_NAVMESHGENERATOR_HH
#define BACKEND_LAYER1_NAVMESHGENERATOR_HH

#include "StaticBitMap.hh"
#include "NavMesh.hh"

namespace Backend {
namespace Layer1 {

    class NavMeshGenerator {
    public:
        /**
         * @brief The main factory method.
         * Reads the static grid, performs Recast/Decomposition, 
         * and populates the NavMesh object.
         * * @param map The input static bitmap (pixels)
         * @param mesh The output graph object to populate
         */
        void ComputeRecast(const StaticBitMap& map, NavMesh& mesh);
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./include/StaticBitMap.hh <==
#ifndef BACKEND_LAYER1_STATICBITMAP_HH
#define BACKEND_LAYER1_STATICBITMAP_HH

#include <vector>
#include <string>
#include "AbstractGrid.hh"

namespace Backend {
namespace Layer1 {

    class StaticBitMap : public AbstractGrid {
    private:
        // Flattened 2D grid: index = y * width + x
        std::vector<bool> gridData;

    public:
        // Default constructor for manual sizing
        StaticBitMap(int w, int h, Backend::Common::Resolution res);

        // Implement the contract
        bool IsAccessible(Backend::Common::Coordinates coords) const override;

        // Load map from file - reads dimensions from first line, then parses grid
        // '.' = walkable, '#' = obstacle
        void LoadFromFile(const std::string& filepath);
        
        // Used by DynamicBitMap to clone data
        const std::vector<bool>& GetRawData() const;
    };

} // namespace Layer1
} // namespace Backend

#endif
==> ./main.cc <==
/**
 * =============================================================================
 * Layer 1 (Mapping) Integration Test Driver
 * =============================================================================
 * 
 * This test validates that the Layer 1 architecture holds together:
 * 1. Static Map Loading from file
 * 2. NavMesh Graph Generation
 * 3. Dynamic/Static isolation for Layer 2/3 separation
 * 
 * =============================================================================
 */

#include <iostream>
#include <cassert>
#include <string>

// Layer 1 includes
#include "StaticBitMap.hh"
#include "DynamicBitMap.hh"
#include "NavMesh.hh"
#include "NavMeshGenerator.hh"
#include "DynamicObstacleGenerator.hh"

// Common includes
#include "Coordinates.hh"
#include "Resolution.hh"

using namespace Backend::Layer1;
using namespace Backend::Common;

// =============================================================================
// ANSI Color Codes for test output
// =============================================================================
#define COLOR_RESET   "\033[0m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_RED     "\033[31m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_CYAN    "\033[36m"

void PrintHeader(const std::string& title) {
    std::cout << "\n" << COLOR_CYAN 
              << "======================================================\n"
              << "  " << title << "\n"
              << "======================================================"
              << COLOR_RESET << "\n\n";
}

void PrintPass(const std::string& test) {
    std::cout << COLOR_GREEN << "[PASS] " << COLOR_RESET << test << std::endl;
}

void PrintFail(const std::string& test) {
    std::cout << COLOR_RED << "[FAIL] " << COLOR_RESET << test << std::endl;
}

// =============================================================================
// MAIN TEST DRIVER
// =============================================================================
int main() {
    std::cout << "\n";
    std::cout << "╔═══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║     LAYER 1 (MAPPING) INTEGRATION TEST                        ║\n";
    std::cout << "║     Multi-Robot System - Backend Architecture Validation      ║\n";
    std::cout << "╚═══════════════════════════════════════════════════════════════╝\n";

    int totalTests = 0;
    int passedTests = 0;

    // =========================================================================
    // TEST 1: Static Map Loading
    // =========================================================================
    PrintHeader("TEST 1: Static Map Loading");

    // Create StaticBitMap with placeholder dimensions (will be overwritten by file)
    StaticBitMap staticMap(300, 200, Resolution::CENTIMETERS);
    
    try {
        staticMap.LoadFromFile("assets/map_layout.txt");
        PrintPass("StaticBitMap loaded from file successfully");
        passedTests++;
    } catch (const std::exception& e) {
        PrintFail("Failed to load StaticBitMap: " + std::string(e.what()));
    }
    totalTests++;

    // Verify dimensions
    auto dims = staticMap.GetDimensions();
    std::cout << "  Map dimensions: " << dims.first << " x " << dims.second << std::endl;
    
    if (dims.first > 0 && dims.second > 0) {
        PrintPass("Map has valid dimensions");
        passedTests++;
    } else {
        PrintFail("Map has invalid dimensions");
    }
    totalTests++;

    // =========================================================================
    // TEST 2: NavMesh Graph Generation
    // =========================================================================
    PrintHeader("TEST 2: NavMesh Graph Generation");

    NavMesh navMesh;
    NavMeshGenerator generator;
    
    generator.ComputeRecast(staticMap, navMesh);
    
    const auto& nodes = navMesh.GetAllNodes();
    std::cout << "  NavMesh nodes created: " << nodes.size() << std::endl;

    if (nodes.size() > 0) {
        PrintPass("NavMesh generated with " + std::to_string(nodes.size()) + " nodes");
        passedTests++;
    } else {
        PrintFail("NavMesh is empty - no nodes generated!");
    }
    totalTests++;

    // Verify we can lookup a node
    if (nodes.size() > 0) {
        int testNodeId = navMesh.GetNodeIdAt(nodes[0].coords);
        if (testNodeId >= 0) {
            PrintPass("Node lookup by coordinate works");
            passedTests++;
        } else {
            PrintFail("Node lookup failed");
        }
        totalTests++;
    }

    // =========================================================================
    // TEST 3: Dynamic/Static Isolation (Critical for Layer 2/3 separation)
    // =========================================================================
    PrintHeader("TEST 3: Dynamic/Static Isolation");

    // Find a walkable coordinate for testing
    // Based on the map, (50, 50) should be in a walkable area
    Coordinates testCoord = {50, 50};
    
    // First, verify the test coordinate is walkable in the static map
    // If not, search for a walkable cell
    if (!staticMap.IsAccessible(testCoord)) {
        std::cout << "  Note: (50,50) is not walkable, searching for walkable cell...\n";
        bool found = false;
        for (int y = 3; y < dims.second - 3 && !found; ++y) {
            for (int x = 3; x < dims.first - 3 && !found; ++x) {
                if (staticMap.IsAccessible({x, y})) {
                    testCoord = {x, y};
                    found = true;
                }
            }
        }
        if (!found) {
            PrintFail("Could not find any walkable cell in the map!");
            return 1;
        }
    }
    
    std::cout << "  Test coordinate: (" << testCoord.x << ", " << testCoord.y << ")\n";

    // Verify it's walkable in static map
    bool staticAccessible = staticMap.IsAccessible(testCoord);
    std::cout << "  StaticBitMap.IsAccessible(" << testCoord.x << ", " << testCoord.y << "): " 
              << (staticAccessible ? "true" : "false") << std::endl;

    if (staticAccessible) {
        PrintPass("Test coordinate is accessible in StaticBitMap (Layer 2 view)");
        passedTests++;
    } else {
        PrintFail("Test coordinate should be accessible in StaticBitMap");
    }
    totalTests++;

    // Create DynamicBitMap from static
    DynamicBitMap dynamicMap(staticMap);

    // Verify it's initially also walkable in dynamic map
    bool dynamicAccessibleBefore = dynamicMap.IsAccessible(testCoord);
    std::cout << "  DynamicBitMap.IsAccessible (before obstacle): " 
              << (dynamicAccessibleBefore ? "true" : "false") << std::endl;

    if (dynamicAccessibleBefore) {
        PrintPass("DynamicBitMap initially matches StaticBitMap");
        passedTests++;
    } else {
        PrintFail("DynamicBitMap should initially match StaticBitMap");
    }
    totalTests++;

    // Create obstacle manager and spawn obstacle at test coordinate
    DynamicObstacleManager obstacleManager;
    obstacleManager.SpawnObstacleAt(testCoord, 1); // Size 1 obstacle

    std::cout << "  Spawned obstacle at (" << testCoord.x << ", " << testCoord.y << ")\n";

    // Update dynamic map with obstacles
    dynamicMap.Update(obstacleManager.GetActiveObstacles(), staticMap);

    // =======================================================================
    // CRITICAL ASSERTION: Verify Layer Isolation
    // =======================================================================
    bool staticAccessibleAfter = staticMap.IsAccessible(testCoord);
    bool dynamicAccessibleAfter = dynamicMap.IsAccessible(testCoord);

    std::cout << "\n" << COLOR_YELLOW << "  >>> CRITICAL ISOLATION TEST <<<" << COLOR_RESET << "\n";
    std::cout << "  StaticBitMap.IsAccessible (after obstacle spawn): " 
              << (staticAccessibleAfter ? "true" : "false") << std::endl;
    std::cout << "  DynamicBitMap.IsAccessible (after obstacle spawn): " 
              << (dynamicAccessibleAfter ? "true" : "false") << std::endl;

    // Static map MUST remain accessible (Layer 2 perspective - planning)
    if (staticAccessibleAfter) {
        PrintPass("StaticBitMap unchanged by dynamic obstacles (Layer 2 isolation OK)");
        passedTests++;
    } else {
        PrintFail("StaticBitMap was modified by dynamic obstacles - ISOLATION BROKEN!");
    }
    totalTests++;

    // Dynamic map MUST be blocked (Layer 3 perspective - real-time)
    if (!dynamicAccessibleAfter) {
        PrintPass("DynamicBitMap correctly blocked by obstacle (Layer 3 sees obstacles)");
        passedTests++;
    } else {
        PrintFail("DynamicBitMap not blocked - obstacle painting failed!");
    }
    totalTests++;

    // =======================================================================
    // FINAL ASSERTION: The layers are properly isolated
    // =======================================================================
    bool isolationValid = staticAccessibleAfter && !dynamicAccessibleAfter;
    
    std::cout << "\n";
    if (isolationValid) {
        std::cout << COLOR_GREEN 
                  << "  ✓ ASSERTION PASSED: Coordinate (" << testCoord.x << "," << testCoord.y 
                  << ") is Accessible in StaticBitMap but Blocked in DynamicBitMap"
                  << COLOR_RESET << "\n";
    } else {
        std::cout << COLOR_RED 
                  << "  ✗ ASSERTION FAILED: Layer isolation is broken!"
                  << COLOR_RESET << "\n";
    }

    // =========================================================================
    // TEST SUMMARY
    // =========================================================================
    std::cout << "\n";
    std::cout << "╔═══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                      TEST SUMMARY                             ║\n";
    std::cout << "╠═══════════════════════════════════════════════════════════════╣\n";
    
    if (passedTests == totalTests) {
        std::cout << "║  " << COLOR_GREEN << "ALL TESTS PASSED: " << passedTests << "/" << totalTests 
                  << COLOR_RESET << "                                   ║\n";
        std::cout << "║  " << COLOR_GREEN << "Layer 1 Architecture: VALIDATED" 
                  << COLOR_RESET << "                           ║\n";
    } else {
        std::cout << "║  " << COLOR_RED << "TESTS PASSED: " << passedTests << "/" << totalTests 
                  << COLOR_RESET << "                                         ║\n";
        std::cout << "║  " << COLOR_RED << "Some tests failed - review output above" 
                  << COLOR_RESET << "                  ║\n";
    }
    
    std::cout << "╚═══════════════════════════════════════════════════════════════╝\n\n";

    return (passedTests == totalTests) ? 0 : 1;
}

==> ./Makefile <==
# ==============================================================================
# Layer 1 (Mapping) Makefile
# ==============================================================================

# Compiler and Flags
CXX := g++
CXXFLAGS := -std=c++17 -Wall -Wextra -g

# Directories
LAYER1_DIR := .
COMMON_DIR := ../common
BUILD_DIR := build

# Include paths (flat structure)
INCLUDES := -I$(LAYER1_DIR)/include -I$(COMMON_DIR)/include

# Source files
LAYER1_SOURCES := $(wildcard $(LAYER1_DIR)/src/*.cc)
COMMON_SOURCES := $(wildcard $(COMMON_DIR)/src/*.cc)
MAIN_SOURCE := main.cc

# Object files (all go into build/)
LAYER1_OBJECTS := $(patsubst $(LAYER1_DIR)/src/%.cc,$(BUILD_DIR)/%.o,$(LAYER1_SOURCES))
COMMON_OBJECTS := $(patsubst $(COMMON_DIR)/src/%.cc,$(BUILD_DIR)/common_%.o,$(COMMON_SOURCES))
MAIN_OBJECT := $(BUILD_DIR)/main.o

ALL_OBJECTS := $(LAYER1_OBJECTS) $(COMMON_OBJECTS) $(MAIN_OBJECT)

# Target executable (inside build directory)
TARGET := test_layer1

# ==============================================================================
# Rules
# ==============================================================================

.PHONY: all clean run

all: $(BUILD_DIR) $(BUILD_DIR)/$(TARGET)

# Create build directory if it doesn't exist
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# Link all objects into executable (output in build/)
$(BUILD_DIR)/$(TARGET): $(ALL_OBJECTS)
	$(CXX) $(CXXFLAGS) -o $@ $^ -pthread

# Compile layer1 source files
$(BUILD_DIR)/%.o: $(LAYER1_DIR)/src/%.cc | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Compile common source files (with prefix to avoid name collision)
$(BUILD_DIR)/common_%.o: $(COMMON_DIR)/src/%.cc | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Compile main.cc
$(BUILD_DIR)/main.o: $(MAIN_SOURCE) | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Run the test executable
run: $(BUILD_DIR)/$(TARGET)
	./$(BUILD_DIR)/$(TARGET)

# Clean build artifacts
clean:
	rm -rf $(BUILD_DIR)

# ==============================================================================
# Debug: Print variables
# ==============================================================================
.PHONY: debug
debug:
	@echo "LAYER1_SOURCES: $(LAYER1_SOURCES)"
	@echo "COMMON_SOURCES: $(COMMON_SOURCES)"
	@echo "LAYER1_OBJECTS: $(LAYER1_OBJECTS)"
	@echo "COMMON_OBJECTS: $(COMMON_OBJECTS)"
	@echo "ALL_OBJECTS: $(ALL_OBJECTS)"
	@echo "TARGET: $(BUILD_DIR)/$(TARGET)"

==> ./src/AbstractGrid.cc <==
#include "AbstractGrid.hh"

namespace Backend {
namespace Layer1 {

    AbstractGrid::AbstractGrid(int w, int h, Backend::Common::Resolution res)
        : width(w), height(h), resolution(res) {}

    std::pair<int, int> AbstractGrid::GetDimensions() const {
        return {width, height};
    }

    bool AbstractGrid::IsWithinBounds(Backend::Common::Coordinates coords) const {
        return coords.x >= 0 && coords.x < width && 
               coords.y >= 0 && coords.y < height;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/DynamicBitMap.cc <==
#include "DynamicBitMap.hh"

namespace Backend {
namespace Layer1 {

    DynamicBitMap::DynamicBitMap(const StaticBitMap& source)
        : AbstractGrid(source.GetDimensions().first, source.GetDimensions().second, Backend::Common::Resolution::METERS) {
        
        activeGrid = source.GetRawData();
    }

    bool DynamicBitMap::IsAccessible(Backend::Common::Coordinates coords) const {
        // LOCK READ
        std::lock_guard<std::mutex> lock(mapMutex);

        if (!IsWithinBounds(coords)) return false;
        return activeGrid[coords.y * width + coords.x];
    }

    void DynamicBitMap::Update(const std::vector<DynamicObstacle>& obstacles, const StaticBitMap& source) {
        // LOCK WRITE
        std::lock_guard<std::mutex> lock(mapMutex);

        // 1. Wipe Canvas (Reset to Static)
        activeGrid = source.GetRawData();

        // 2. Paint Obstacles
        for (const auto& obs : obstacles) {
            for (const auto& cell : obs.GetOccupiedCells()) {
                if (IsWithinBounds(cell)) {
                    activeGrid[cell.y * width + cell.x] = false;
                }
            }
        }
    }

} // namespace Layer1
} // namespace Backend
==> ./src/DynamicObstacle.cc <==
#include "DynamicObstacle.hh"

namespace Backend {
namespace Layer1 {

    DynamicObstacle::DynamicObstacle(Backend::Common::Coordinates anchor, int s)
        : size(s), top_left_anchor(anchor) {}

    std::vector<Backend::Common::Coordinates> DynamicObstacle::GetOccupiedCells() const {
        std::vector<Backend::Common::Coordinates> cells;
        cells.reserve(size * size); 

        for (int x = 0; x < size; ++x) {
            for (int y = 0; y < size; ++y) {
                cells.push_back({
                    top_left_anchor.x + x,
                    top_left_anchor.y + y
                });
            }
        }
        return cells;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/DynamicObstacleGenerator.cc <==
#include "DynamicObstacleGenerator.hh"
#include <cstdlib> // rand
#include <ctime>   // time

namespace Backend {
namespace Layer1 {

    void DynamicObstacleManager::SpawnRandomObstacle(int mapWidth, int mapHeight) {
        int size = (std::rand() % 3) + 1; // Random size 1-3
        
        int maxX = mapWidth - size;
        int maxY = mapHeight - size;

        if (maxX <= 0 || maxY <= 0) return; 

        int x = std::rand() % maxX;
        int y = std::rand() % maxY;

        active_obstacles.emplace_back(Backend::Common::Coordinates{x, y}, size);
    }

    void DynamicObstacleManager::SpawnObstacleAt(Backend::Common::Coordinates coords, int size) {
        active_obstacles.emplace_back(coords, size);
    }

    const std::vector<DynamicObstacle>& DynamicObstacleManager::GetActiveObstacles() const {
        return active_obstacles;
    }

    void DynamicObstacleManager::Clear() {
        active_obstacles.clear();
    }

} // namespace Layer1
} // namespace Backend
==> ./src/NavMesh.cc <==
#include "NavMesh.hh"
#include <cmath>
#include <limits>

namespace Backend {
namespace Layer1 {

    NavMesh::NavMesh() {}

    const std::vector<Backend::Common::Node>& NavMesh::GetAllNodes() const {
        return allNodes;
    }

    const std::vector<Backend::Common::Edge>& NavMesh::GetNeighbors(int nodeId) const {
        if (nodeId < 0 || nodeId >= (int)adjacencyList.size()) {
            static const std::vector<Backend::Common::Edge> empty;
            return empty;
        }
        return adjacencyList[nodeId];
    }

    int NavMesh::GetNodeIdAt(Backend::Common::Coordinates coords) const {
        // Naive implementation: Linear Search for nearest centroid.
        // OPTIMIZATION: In production, use a Spatial Hash, QuadTree, or 2D Grid Lookup.
        
        int bestNode = -1;
        float minDist = std::numeric_limits<float>::max();

        for (int i = 0; i < (int)allNodes.size(); ++i) {
            float dist = coords.DistanceTo(allNodes[i].coords);
            
            // Simple threshold: If we are close enough to a node center
            // (You might want strict polygon containment checks here later)
            if (dist < minDist) {
                minDist = dist;
                bestNode = i;
            }
        }
        
        // Threshold check (e.g., must be within 5 units of a node)
        // if (minDist > 5.0f) return -1; 

        return bestNode;
    }

    void NavMesh::AddNode(Backend::Common::Coordinates centroid) {
        Backend::Common::Node n;
        n.coords = centroid;
        allNodes.push_back(n);
        
        // Resize adjacency list to match node count
        adjacencyList.resize(allNodes.size());
    }

    void NavMesh::AddEdge(int sourceId, int targetId, float cost) {
        if (sourceId >= 0 && sourceId < (int)adjacencyList.size()) {
            Backend::Common::Edge e;
            e.targetNodeId = targetId;
            e.cost = cost;
            adjacencyList[sourceId].push_back(e);
        }
    }

} // namespace Layer1
} // namespace Backend
==> ./src/NavMeshGenerator.cc <==
// layer1/src/NavMeshGenerator.cc

#include "NavMeshGenerator.hh"
#include <vector>
#include <cmath>
#include <algorithm>
#include <iostream>

namespace Backend {
namespace Layer1 {

    // INTERNAL HELPER STRUCT
    // Represents a walkable region we discovered
    struct RectangleRegion {
        int id;
        int x, y; // Top-left
        int w, h; // Dimensions
        
        Backend::Common::Coordinates GetCentroid() const {
            return { x + w / 2, y + h / 2 };
        }

        // Check if this rectangle shares a border with 'other'
        bool IsNeighbor(const RectangleRegion& other) const {
            // Check for overlap on X axis (Vertical Adjacency)
            bool xOverlap = (x < other.x + other.w) && (x + w > other.x);
            bool touchesVertical = (y + h == other.y) || (y == other.y + other.h);
            
            if (xOverlap && touchesVertical) return true;

            // Check for overlap on Y axis (Horizontal Adjacency)
            bool yOverlap = (y < other.y + other.h) && (y + h > other.y);
            bool touchesHorizontal = (x + w == other.x) || (x == other.x + other.w);

            if (yOverlap && touchesHorizontal) return true;

            return false;
        }
    };

    // =========================================================
    // MAIN COMPUTE FUNCTION
    // =========================================================
    void NavMeshGenerator::ComputeRecast(const StaticBitMap& map, NavMesh& mesh) {
        std::cout << "[NavMeshGenerator] Starting Rectangular Decomposition..." << std::endl;

        auto dims = map.GetDimensions();
        int mapW = dims.first;
        int mapH = dims.second;

        // 1. Create a working copy of the grid to mark "visited" areas
        // We use a flat vector<bool> where false = visited/obstacle, true = needs processing
        std::vector<bool> remainingSpace(mapW * mapH, false);

        // Initialize: Copy walkability from StaticBitMap
        for (int y = 0; y < mapH; ++y) {
            for (int x = 0; x < mapW; ++x) {
                if (map.IsAccessible({x, y})) {
                    remainingSpace[y * mapW + x] = true;
                }
            }
        }

        std::vector<RectangleRegion> regions;
        int regionIdCounter = 0;

        // 2. DECOMPOSITION LOOP
        // Greedily find the largest rectangles
        for (int y = 0; y < mapH; ++y) {
            for (int x = 0; x < mapW; ++x) {
                
                // If this cell is walkable and not yet part of a rectangle
                if (remainingSpace[y * mapW + x]) {
                    
                    // A. Find Max Width
                    int width = 0;
                    while (x + width < mapW && remainingSpace[y * mapW + (x + width)]) {
                        width++;
                    }

                    // B. Find Max Height for this Width
                    int height = 1;
                    bool canExpandDown = true;
                    while (y + height < mapH && canExpandDown) {
                        // Check the entire row below
                        for (int k = 0; k < width; ++k) {
                            if (!remainingSpace[(y + height) * mapW + (x + k)]) {
                                canExpandDown = false;
                                break;
                            }
                        }
                        if (canExpandDown) height++;
                    }

                    // C. Create the Region
                    RectangleRegion region;
                    region.id = regionIdCounter++;
                    region.x = x;
                    region.y = y;
                    region.w = width;
                    region.h = height;
                    regions.push_back(region);

                    // D. Mark these cells as visited (false) in remainingSpace
                    for (int dy = 0; dy < height; ++dy) {
                        for (int dx = 0; dx < width; ++dx) {
                            remainingSpace[(y + dy) * mapW + (x + dx)] = false;
                        }
                    }
                }
            }
        }

        std::cout << "[NavMeshGenerator] Decomposed map into " << regions.size() << " convex regions." << std::endl;

        // 3. GENERATE NODES
        // Convert our Regions into NavMesh Nodes
        for (const auto& reg : regions) {
            mesh.AddNode(reg.GetCentroid());
        }

        // 4. GENERATE EDGES (Connectivity)
        // Check adjacency between all regions (O(N^2))
        // Since N is usually small (< 500 for a warehouse), this is instant.
        int edgesCount = 0;
        for (size_t i = 0; i < regions.size(); ++i) {
            for (size_t j = i + 1; j < regions.size(); ++j) {
                
                if (regions[i].IsNeighbor(regions[j])) {
                    // Calculate Cost (Distance between centroids)
                    float cost = regions[i].GetCentroid().DistanceTo(regions[j].GetCentroid());

                    // Add Bi-Directional Edge
                    mesh.AddEdge(regions[i].id, regions[j].id, cost);
                    mesh.AddEdge(regions[j].id, regions[i].id, cost);
                    edgesCount++;
                }
            }
        }

        std::cout << "[NavMeshGenerator] Graph Built: " << edgesCount << " edges created." << std::endl;
    }

} // namespace Layer1
} // namespace Backend
==> ./src/StaticBitMap.cc <==
#include "StaticBitMap.hh"
#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>

namespace Backend {
namespace Layer1 {

    StaticBitMap::StaticBitMap(int w, int h, Backend::Common::Resolution res)
        : AbstractGrid(w, h, res) {
        // Initialize all true (walkable)
        gridData.resize(w * h, true);
    }

    bool StaticBitMap::IsAccessible(Backend::Common::Coordinates coords) const {
        if (!IsWithinBounds(coords)) return false;
        return gridData[coords.y * width + coords.x];
    }

    void StaticBitMap::LoadFromFile(const std::string& filepath) {
        std::cout << "[StaticBitMap] Loading map layout from: " << filepath << std::endl;
        
        std::ifstream file(filepath);
        if (!file.is_open()) {
            throw std::runtime_error("[StaticBitMap] Failed to open file: " + filepath);
        }

        // Read dimensions from first line
        int fileWidth, fileHeight;
        file >> fileWidth >> fileHeight;
        file.ignore(); // Skip the newline after dimensions

        if (fileWidth != width || fileHeight != height) {
            std::cout << "[StaticBitMap] Warning: File dimensions (" << fileWidth << "x" << fileHeight 
                      << ") differ from initialized dimensions (" << width << "x" << height << ")." << std::endl;
            // Resize to match file
            width = fileWidth;
            height = fileHeight;
            gridData.resize(width * height, true);
        }

        // Read the grid data row by row
        std::string line;
        int y = 0;
        while (std::getline(file, line) && y < height) {
            for (int x = 0; x < width && x < (int)line.size(); ++x) {
                char c = line[x];
                // '.' = walkable (true), '#' = obstacle (false)
                gridData[y * width + x] = (c == '.');
            }
            ++y;
        }

        file.close();
        
        // Count walkable cells for stats
        int walkable = 0;
        for (bool cell : gridData) {
            if (cell) walkable++;
        }
        
        std::cout << "[StaticBitMap] Loaded " << width << "x" << height << " map. "
                  << "Walkable cells: " << walkable << " / " << (width * height) << std::endl;
    }

    const std::vector<bool>& StaticBitMap::GetRawData() const {
        return gridData;
    }

} // namespace Layer1
} // namespace Backend
==> ./utils/map_baker.py <==
from PIL import Image
import sys
import os

def parse_dimensions(dim_str):
    """Parses a string like '30x20' into tuple (30.0, 20.0)."""
    try:
        # Normalize to lowercase 'x'
        parts = dim_str.lower().split('x')
        if len(parts) != 2:
            raise ValueError
        width = float(parts[0])
        height = float(parts[1])
        return width, height
    except ValueError:
        print(f"Error: Invalid dimension format '{dim_str}'. Expected format: WIDTHxHEIGHT (e.g., 30x20)")
        sys.exit(1)

def convert_png_to_grid(input_path, output_path, physical_dims, threshold=128):
    try:
        # 1. Load Image
        if not os.path.exists(input_path):
            print(f"Error: File {input_path} not found.")
            return

        original_img = Image.open(input_path)
        original_img = original_img.convert('L') # Grayscale
        
        real_w_meters, real_h_meters = physical_dims

        print(f"\n--- MAP CONFIGURATION ---")
        print(f"Input Image:      {input_path}")
        print(f"Physical Size:    {real_w_meters}m (Width) x {real_h_meters}m (Height)")
        print(f"Physical Area:    {real_w_meters * real_h_meters} m^2")

        # 2. Define Options based on Backend::Common::Resolution
        # Multiplier = Cells per meter
        options = {
            1: ("METERS", 1.0),         # 1 cell = 1m
            2: ("DECIMETERS", 10.0),    # 1 cell = 0.1m (10 cells/m)
            3: ("CENTIMETERS", 100.0),  # 1 cell = 0.01m
            4: ("MILLIMETERS", 1000.0)  # 1 cell = 0.001m
        }

        print("\n--- SELECT RESOLUTION ---")
        # Header
        print(f"{'Opt':<5} {'Name':<15} {'Grid Size (WxH)':<20} {'Total Cells'}")
        print("-" * 60)

        # Calculate and display grid sizes for each option
        for key, (name, multiplier) in options.items():
            grid_w = int(real_w_meters * multiplier)
            grid_h = int(real_h_meters * multiplier)
            total = grid_w * grid_h
            
            warning = " (!! HEAVY !!)" if total > 10000000 else ""
            print(f"{key:<5} {name:<15} {grid_w}x{grid_h:<15} {total}{warning}")

        # 3. Get User Selection
        try:
            choice_str = input("\nSelect Option (1-4): ")
            choice = int(choice_str)
            if choice not in options:
                print("Invalid option.")
                return
        except ValueError:
            print("Invalid input.")
            return

        selected_name, multiplier = options[choice]
        
        # Final Grid Calculation
        target_w = int(real_w_meters * multiplier)
        target_h = int(real_h_meters * multiplier)

        print(f"\nProcessing as {selected_name}...")
        print(f"Resizing image to grid dimensions: {target_w}x{target_h}...")

        # 4. Resize Image (LANCZOS for quality)
        # This implicitly handles aspect ratio distortion if your PNG doesn't match your meters.
        # e.g. If PNG is square but meters are 30x10, the image will stretch to fit 30x10.
        
        resized_img = original_img.resize((target_w, target_h), Image.Resampling.LANCZOS)
        
        pixels = list(resized_img.getdata())

        # 5. Write to Text File
        with open(output_path, 'w') as f:
            # Header: Width Height
            f.write(f"{target_w} {target_h}\n")
            
            # Grid Data
            for y in range(target_h):
                row_str = ""
                for x in range(target_w):
                    pixel_val = pixels[y * target_w + x]
                    
                    # LOGIC: Dark = Wall (#), Light = Floor (.)
                    if pixel_val < threshold:
                        row_str += "#"
                    else:
                        row_str += "."
                
                f.write(row_str + "\n")
                
        print(f"\nSUCCESS! Map saved to: {output_path}")
        print(f"Grid Dimensions: {target_w} x {target_h}")

    except Exception as e:
        print(f"Critical Error: {e}")

if __name__ == "__main__":
    # Usage Check
    if len(sys.argv) < 4:
        print("Usage: python3 map_baker.py <input_png> <output_txt> <WxH_meters>")
        print("Example: python3 utils/map_baker.py warehouse.png map.txt 30x20")
    else:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        dimensions = parse_dimensions(sys.argv[3])
        
        convert_png_to_grid(input_file, output_file, dimensions)