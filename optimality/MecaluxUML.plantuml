@startuml Mecalux_Final_Architecture_Corrected

allowmixing
skinparam linetype ortho
skinparam nodesep 50
skinparam ranksep 60
skinparam groupInheritance 2

' === 1. TOP LEVEL: EXTERNAL API ===
namespace API {
    artifact "set_of_tasks.json" as TasksJson
}

namespace Backend {

    ' === 2. THE ORCHESTRATOR (Top Center) ===
    class FleetManager <<Active>> {
        ' --- Shared State ---
        - Map<int, Layer2.Logic.RobotAgent> fleetRegistry
        - Layer1.Output.DynamicBitMap* dynamicMap
        
        ' --- Sync ---
        - Mutex fleetMutex
        - Mutex mapMutex
        
        ' --- Threads ---
        - Thread fleetThread
        - Thread obstacleThread
        - Thread mainThread
        
        ' --- Methods ---
        + Start(): void
        + Stop(): void
        - runFleetLoop(): void
        - runObstacleLoop(): void
        - runMainLoop(): void
    }
    
    class SystemConstants <<Static>> {
        + {static} const int FLEET_STATE_UPDATE_TICK_MS = 50
        + {static} const int OBSTACLE_UPDATE_TICK_MS = 100
    }

    ' === 3. SHARED TYPES (Top Right) ===
    namespace Common {
        class Coordinates {
            + x: int
            + y: int
            + DistanceTo(other: Coordinates): float
        }
        
        ' Added Vector2 as requested for Layer 3
        class Vector2 {
            + x: double
            + y: double
            + magnitude(): double
            + normalize(): Vector2
        }

        struct Node {
            + Coordinates coords
        }
        
        struct Edge {
            + int targetNodeId
            + float cost
        }

        struct Task {
            + int taskId
            + int sourceNode
            + int destinationNode
        }
    }

    ' === 4. THE LAYERS (Bottom Row) ===
    
    ' --- LAYER 1: MAPPING (LEFT) ---
    namespace Layer1 {
        abstract class AbstractGrid {
            # int width
            # int height
            # Resolution res
            
            + IsAccessible(c: Coordinates): bool
            + GetDimensions(): Pair<int,int>
        }
        
        package Input {
            class StaticBitMap {
                + LoadFromFile(): void
            }
        }
        package Core {
            class NavMeshGenerator {
                + compute_Recast()
            }
            class DynamicObstacle {
                - int size
                - Coordinates top_left_anchor                
                + GetOccupiedCells(): List<Coordinates>
            }
            class DynamicObstacleManager {
                - List<DynamicObstacle> active_obstacles
                + SpawnRandomObstacle(): void
            }
        }
        package Output {
            class NavMesh {
                - vector<vector<Edge>> adjacencyList
                - vector<Node> allNodes
                + getAllNodes(): vector<Node>
                + getNodeIdAt(c: Coordinates): int
            }
            class DynamicBitMap {
                + update(obstacles: set<DynamicObstacle>): bool
            }
        }
        
        ' Relations (Horizontal Flow enforced by .right.)
        Input.StaticBitMap -up-|> AbstractGrid
        Output.DynamicBitMap -up-|> AbstractGrid
        Input.StaticBitMap <.right. Core.NavMeshGenerator
        Core.NavMeshGenerator .right.> Output.NavMesh
        Core.DynamicObstacleManager .right.> Output.DynamicBitMap
        
        ' Horizontal Layout Hints for Layer 1
        Input -[hidden]right- Core
        Core -[hidden]right- Output
    }

    ' --- LAYER 2: LOGIC (CENTER) ---
    namespace Layer2 {
        package Input {
            class TaskLoader {
                + {static} LoadTasks(path: String, mesh: NavMesh): vector<Task>
            }
        }
        package Logic {
            enum robotStatus {
                IDLE,
                BUSY,
                CHARGING,
                ERROR
            }
        
            struct RobotState {
                - int currentNodeId
                - robotStatus status
                - float currentBatteryLevel
                - List<int> currentItinerary
            }
            class RobotAgent {
                - int robotId
                - float totalBatteryCapacity
                - int chargingStationNodeId
                - float averageSpeed_meters_per_second
                - int capacity
                - RobotState currentState
                + updateState()
                ' Added Assignment Method as argued
                + assignItinerary(nodes: List<int>): void
            }
            class CostMatrixProvider {
                - Map<Pair<int,int>, float> costsMatrix
                + getCost(from: int, to: int): float
            }
            interface IVRPSolver {
                + solve(tasks: List<Task>, robots: List<RobotAgent>, costs: CostMatrixProvider): Map<int, List<int>>
            }
            class HillClimbing implements IVRPSolver {
                + solve(tasks: List<Task>, robots: List<RobotAgent>, costs: CostMatrixProvider): Map<int, List<int>>
            }
            class SimulatedAnnealing implements IVRPSolver {
                + solve(tasks: List<Task>, robots: List<RobotAgent>, costs: CostMatrixProvider): Map<int, List<int>>
            }
        }
        
        ' Relations
        Input.TaskLoader ..> Backend.Layer1.Output.NavMesh : <<Uses>>
        Logic.CostMatrixProvider ..> Backend.Layer1.Output.NavMesh : <<Queries>>
    }

    ' --- LAYER 3: DRIVER (RIGHT) ---
    namespace Layer3 {
        package Pathfinding {
            enum RequestPriority {
                HIGH_REPLAN
                NORMAL_NEXT_GOAL
            }
            struct PathRequest {
                + int robotId
                + Coordinates start
                + Coordinates end
                + RequestPriority priority
            }
            class ThetaStarSolver {
                + {static} ComputePath(start: Coordinates, end: Coordinates, map: DynamicBitMap): List<Coordinates>
            }
            class PathfindingService <<Singleton>> {
                - PriorityQueue<PathRequest> requestQueue
                - List<Thread> workerPool
                + RequestPath(req: PathRequest, callback: Function): void
                - processNextRequest(): void
            }
        }
    
        package Physics {
            struct ObstacleData {
                + Coordinates position
                + Vector2 velocity
                + double radius
            }
            class ORCASolver {
                + {static} CalculateSafeVelocity(me: ObstacleData, neighbors: List<ObstacleData>, preferredVel: Vector2): Vector2
            }
        }
    
        package Core {
            class RobotDriver {
                - int robotId
                - List<Coordinates> currentPath
                - int pathIndex
                - Vector2 currentVelocity
                - sendToSimulator(v: Vector2): void
                + setGoal(nodeId: int): void
                + updateLoop(dt: float, neighbors: List<ObstacleData>): void
                - calculatePreferredVelocity(): Vector2
                + onPathFound(newPath: List<Coordinates>): void
            }
            class FastLoopManager <<Active>> {
                - List<RobotDriver> drivers
                + runPhysicsLoop(): void
            }
        }
    
        ' Relations
        Pathfinding.PathfindingService o-- Pathfinding.PathRequest
        Pathfinding.PathfindingService ..> Pathfinding.ThetaStarSolver : <<Calls>>
        Pathfinding.ThetaStarSolver ..> Backend.Layer1.Output.DynamicBitMap : <<Reads>>
        Physics.ORCASolver ..> Physics.ObstacleData : <<Uses>>
        Core.RobotDriver ..> Pathfinding.PathfindingService : <<Requests Path>>
        Core.RobotDriver ..> Physics.ORCASolver : <<Calculates Avoidance>>
        Core.FastLoopManager *-- Core.RobotDriver : <<Owns>>
        Core.RobotDriver ..> Backend.Common.Vector2 : <<Uses>>
    }
    
    ' === 5. SYSTEM LAYOUT & CONNECTIONS ===
    
    ' Wiring The Manager
    Backend.FleetManager ..> Layer2.Input.TaskLoader : <<Calls>>
    Backend.FleetManager --> Layer2.Logic.IVRPSolver : <<Delegates>>
    Backend.FleetManager o-- Layer2.Logic.RobotAgent : <<Owns>>
    
    ' Corrected path to RobotDriver in Layer 3 Core
    Backend.FleetManager --> Backend.Layer3.Core.RobotDriver : <<Commands>>
    
    ' Wiring The API
    Layer2.Input.TaskLoader .up.> API.TasksJson : <<Parses>>

    ' === CRITICAL LAYOUT ADJUSTMENTS ===
    ' 1. Vertical Stack: API -> Manager -> Layer2
    API -[hidden]down- Backend.FleetManager
    Backend.FleetManager -[hidden]down- Backend.Layer2
    
    ' 2. Top Row: Manager (Center) -> Common (Right)
    Backend.FleetManager -[hidden]right- Backend.Common
    
    ' 3. Bottom Row: Layer1 (Left) -> Layer2 (Center) -> Layer3 (Right)
    Backend.Layer1 -[hidden]right- Backend.Layer2
    Backend.Layer2 -[hidden]right- Backend.Layer3
    
    ' 4. Ensure Layer 1 stays below Common/Manager area
    Backend.Common -[hidden]down- Backend.Layer2
}

@enduml